# PBI-62: Wire Pre-built Fuse Index in Edge Function

> Status: Ready

## Directive

Connect the pre-built Fuse.js index (generated by PBI-60) to the updated ContentService (from PBI-61) in the Netlify Edge Function, completing the production fuzzy search pipeline.

**Scope:**
- `netlify/edge-functions/mcp.ts` (modify)

## Dependencies
- Blocked by: PBI-60 (index file must exist at `src/mcp/fuse-index.json`), PBI-61 (ContentService must accept optional `fuseIndex` parameter)
- Must merge before: None (final PBI in this epic)

## Context
Ref: `plans/mcp-server/mcp-search.md` — Section: "Edge Function Changes"

Currently `mcp.ts:22` imports `articles.json` and `mcp.ts:30` passes it to `new ContentService(articles)`. After this PBI, it also imports `fuse-index.json`, parses it with `Fuse.parseIndex()`, and passes it as the second constructor argument so the production search path uses the pre-built index.

## Changes Required

**`netlify/edge-functions/mcp.ts`:**

Add two imports after the existing `articles.json` import (line 22):

```typescript
// @ts-ignore: JSON import
import fuseIndexData from '../../src/mcp/fuse-index.json' with { type: 'json' };
import Fuse from 'fuse.js';
```

Note: Use `with { type: 'json' }` — NOT the deprecated `assert` syntax. Match the convention already used on line 22 for `articles.json`.

Add type import for Article:

```typescript
import { ContentService, type Article } from '../../src/mcp/content.ts';
```

Update the `getMcpServer()` function (lines 28-34) to parse the Fuse index and pass it to ContentService:

```typescript
function getMcpServer() {
  if (!mcpServer) {
    const fuseIndex = Fuse.parseIndex<Article>(fuseIndexData);
    contentService = new ContentService(articles as any, fuseIndex);
    mcpServer = new McpServer(contentService);
  }
  return mcpServer;
}
```

The only change inside `getMcpServer()` is:
1. Parse the imported index data with `Fuse.parseIndex<Article>()`
2. Pass it as the second argument to `ContentService`

No other changes to the file. SSE handling, JSON-RPC routing, CORS — all unchanged.

## Verification
- [ ] Edge function imports `fuse-index.json` with `with { type: 'json' }` syntax
- [ ] Edge function imports `Fuse` from `fuse.js`
- [ ] Edge function imports `Article` type from `content.ts`
- [ ] `Fuse.parseIndex<Article>()` is called with the imported index data
- [ ] `ContentService` constructor receives the parsed index as second argument
- [ ] All existing edge function tests pass (`pnpm test:run`)
- [ ] `pnpm check` — zero type errors
- [ ] `pnpm build` — full build succeeds end-to-end (prebuild generates index, build bundles edge function)

## Notes
- The `@ts-ignore` comment is needed for the JSON import because Deno and Node handle JSON imports differently. This matches the existing pattern on line 22.
- `fuse-index.json` is generated during `prebuild` (`node scripts/generate-mcp-index.mjs`), which runs before `pnpm build`. The file will exist when the edge function is bundled.
- If Fuse.js has Deno/Netlify Edge compatibility issues, this is the PBI that will surface them. Fuse.js is pure JS with ESM support, so risk is low. Fallback if needed: vendor a local copy of Fuse.js.
- Verify with `netlify dev` locally after implementation — call `search_knowledge_base` with a typo query and confirm fuzzy results are returned.

## Blocks
- None (final PBI in epic)

## Related
- Spec: `plans/mcp-server/mcp-search.md`
- Edge function: `netlify/edge-functions/mcp.ts`
- PBI-60: Generates the `fuse-index.json` file
- PBI-61: Updates ContentService to accept the index
